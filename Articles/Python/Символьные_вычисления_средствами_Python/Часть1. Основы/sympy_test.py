# https://habr.com/post/423731/

import pprint
from fractions import Fraction
from sympy import oo, sin, cos, tan, pi, E, S, symbols, var, Rational, Integer, sqrt


"""Явное объявление символьных переменных"""

"""Для символьных вычислений с помощью модуля SymPy символьные переменные и функции
должны быть объявлены как таковые. """
# symbols(): возвращает ссылку на символьный объект в виде какой-либо переменной
# var(): без присваивания создает символьную переменную

x, y, a, b = symbols('x y a b')  # созданы четыре символьные переменные, предыдущие же значения переменных затираются
print(f"type(x): {type(x)}")
f = (a**3 * x) + (3 * a**2 * x**2 / 2) + (a * x**3) + (x**4 / 4)  # переменная f становится автоматически символьной
print(f"type(f): {type(f)}")
print(f"f: {f}\n")

var('u, v')
print(f"type(u): {type(u)}")
f = sin(u) ** 2 + tan(v)  # переменная f автоматически становится символьной
print(f"type(f): {type(f)}")
print(f"f: {f}\n")

# В функциях symbols() и var() можно объявлять символьные переменные с индексом:
# диапазон индексов от 0 до 8
x = symbols('x:9')
print(f"x: {x}")

# диапазон индексов от 5 до 9
x = symbols('x5:10')
print(f"x: {x}")

# диапазон индексов от 0 до 8
x = var('x:9')
print(f"x: {x}")

# диапазон индексов от 5 до 9
x = var('x5:10')
print(f"x: {x}\n")



"""Также можно назначить тип и накладывать ограничения на символьные переменные прямо в функциях symbols() и var().
Иногда без таких ограничений очевидные преобразования не работают, например, сравните:"""
x = symbols('x', integer=True)  # назначаем целый тип
print(f"sqrt(x**2): {sqrt(x**2)}")

x = symbols('x', positive=True, integer=True)
print(f"sqrt(x**2): {sqrt(x**2)}")

x = symbols('x')
print(f"sqrt(x**2): {sqrt(x**2)}")  # это x, если x ≥ 0

x = var('x', integer=True)
print(f"sqrt(x**2): {sqrt(x**2)}")

x = var('x', positive=True, integer=True)
print(f"sqrt(x**2): {sqrt(x**2)}")

x = var('x')
print(f"sqrt(x**2): {sqrt(x**2)}\n")  # это x, если x ≥ 0

# Чтобы создать контейнер для одиночного символа, используем аргумент seq=True:
print(f"symbols('x',seq=True): {symbols('x',seq=True)}\n")

# Определение действительных значений для символьных переменных:
x, y, z = symbols('x, y, z', real=True)
print(f"x.is_real and y.is_real and z.is_real: {x.is_real and y.is_real and z.is_real}\n")




"""Функция S()"""
print('Функция S()')

"""Иногда символьные выражения могут быть проинтерпретированы как числовые константы Python, а не SymPy.
Поэтому для объявления символьных переменных, а также для преобразования числовых констант в символьные,
применяют функцию S(), например, сравним:"""
expr = x**2 + sin(y) + S(10)/2
print(f"expr: {expr}")

print(f"type(10): {type(10)}")
print(f"type(S(10)): {type(S(10))}\n")

""""Разница между постоянной Python и символьной состоит в том, что символьная константа может быть вычислена
с заданной степенью точности, как показано в следующем примере в сравнении со стандартной функцией round():"""
# вычисляет переменную z с процессорной точностью
z = 1/7
print(f"z: {z}")
z1 = S(1)/7
print(f"z1: {z1}")

# вычисляет переменную z2 с точностью до 30 значащих цифр
z2 = z1.n(30)
print(f"z2: {z2}")

z3 = round(z1, 30)
print(f"z3: {z3}\n")




"""Cимвольные имена"""
print('Cимвольные имена')


"""Если в текущей сессии необходимо использовать символьную математику постоянно,
то можно импортировать общепринятые символьные имена из модуля sympy.abc:"""
import sympy.abc

print(f"dir(sympy.abc): {pprint.pprint(dir(sympy.abc), compact=True)}")

# Имя переменной из пространства имен можно удалить командой del имя1, имя2,..:
print(f"type(x): {type(x)}")
del x, y
try:
    print(f"x: {x}")
except NameError as e:
    print(repr(e) + '\n')

"""Для восстановления значений стандартных констант, а также имен некоторых функций,
нужно повторно загрузить модуль sympy."""
# from sympy import *
try:
    print(f"x: {x}")
except NameError as e:
    print(repr(e) + '\n')




"""Метод subs(...)"""
print('Метод subs(...)')

# Следует помнить, что при записи символьного выражения может автоматически выполняться его упрощение, например:
a, b, c, d, x, y, z, u, v, w = symbols('a b c d x y z u v w')
print(f"x - z + 20 - z - 15 + 3*sin(pi/2) + 2*z = {x - z + 20 - z - 15 + 3*sin(pi/2) + 2*z}")

# Метод subs(...) используется для вычисления символьного выражения при заданных значениях переменных, например:
a, x = symbols('a x')
f = a**3 * x + 3 * a**2 * x**2/2 + a * x**3 + x**4/4

# в выражение f вместо переменной a была подставлена единица
print(f"f.subs(a,1): {f.subs(a,1)}\n")

"""Если в методе subs использовать два аргумента, то они интерпретируются как subs(old,new),
т.е. старый идентификатор old заменяется новым new. Аргумент метода subs() может быть последовательностью,
которая должна содержать пары (old,new), а может быть символьным выражением, например:"""
a, b, c, d, x, y, z = symbols('a b c d x y z')
f = a * x**3 + b * y**2 + c*z + d

# выполнена подстановка a=1, b=2, c=3, d=4
print(f"f.subs([(a, 1),(b, 2),(c, 3),(d, 4)]): {f.subs([(a, 1),(b, 2),(c, 3),(d, 4)])}")

pr = x**3 + 4 * x**2 + 6*x + 10
# выполнена подстановка символьного выражения
print(f"pr.subs(x, 1/x): {pr.subs(x, 1/x)}")

"""Обратим ваше внимание на следующую особенность работы с переменными (символьными и обычными переменными Python).
Выполним следующий код:"""
x = 'Hello'
pr = x + ', world'
print(f"pr: {pr}")

# присвоили символьной переменной x новое значение
x = 'AAA'
print(f"pr: {pr}\n")

"""Здесь действует правило: если переменная изменилась, то созданное ранее выражение, содержащее эту переменную,
не пересчитывается автоматически. Это правило срабатывает и для обычных переменных Python."""




"""Операции с дробями"""
print('Операции с дробями')

# Модуль SymPy может проводить вычисления с дробями и приводить их к общему знаменателю, например, сравните:
print(f"S(1)/3 + S(2)/5 = {S(1)/3 + S(2)/5}")
print(f"1/3 + 2/5 = {1/3 + 2/5}")
print(f"1/3 + 2/5 = {Fraction(1, 3) + Fraction(2, 5)}")
print(f"(S(1)/3 + S(2)/5).n(30) = {(S(1)/3 + S(2)/5).n(50)}\n")

"""Функции Rational(числитель, знаменатель) и Integer(...) используются для создания
рациональных дробей без десятичного округления:"""
z = Rational(1, 7) + Rational(2, 5)
print(f"z = {z}")
print(f"Integer(1)/Integer(5) = {Integer(1)/Integer(5)}")
print(f"1/5 = {1/5}")
z = Integer(1)/Integer(5) + Rational(2, 7)
print(f"z = {z}\n")




"""Округления вычислений"""
print('Округления вычислений')

"""В символьных вычислениях работает правило – если ничего не сказано, не делать никаких округлений.
Посмотрите, как в первом случае Python преобразует выражение, но оставит в записи ответа квадратный корень
и не выполнит никаких округлений, а во втором, так как одно из чисел задано с десятичной точкой,
результат будет приближенным:"""
print(f"sqrt(20) = {sqrt(20)}")

# в выражении используется число с десятичной точкой
print(f"sqrt(20.0) = {sqrt(20.0)}")

"""Для любого символьного объекта существует метод evalf(...)(evaluate float),
который возвращает его десятичное представление:"""
# функция sqrt() модуля sympy
print(f"sqrt(20).evalf() = {sqrt(20).evalf()}")
print(f"E = {E}")
print(f"E.evalf() = {E.evalf()}")

# В методе evalf([n,...]) можно использовать аргумент, задающий точность результата (n = количество значащих цифр)
print(f"sqrt(20).evalf(30) = {sqrt(20).evalf(30)}")
print(f"pi.evalf(20) = {pi.evalf(20)}")

# Также всегда нужно помнить, что вещественная арифметика не возвращает точный результат, сравните:
one = S('one')
one = cos(1)**2 + sin(1)**2
print(f"one.evalf() = {one.evalf()}")

# должно быть равно 0
print(f"(one-1).evalf() = {(one-1).evalf()}")

"""Если известно, что результат содержит погрешность вычислений, то с помощью опции chop=True
метода evalf() ее можно удалить. Очень маленькое значение вещественной или мнимой части результата
в этом случае заменяется нулем. Возьмем предыдущий пример:"""
print(f"(one-1).evalf(chop=True) = {(one-1).evalf(chop=True)}\n")




"""Бесконечность"""
print('Бесконечность')

"""После выполнения первой строки from sympy import * становится доступен символ бесконечности – oo (две буквы „o‟),
с которым тоже можно выполнять определенные операции:"""
print(f"oo+1 = {oo+1}")
print(f"1000000 < oo: {1000000 < oo}")
print(f"1/oo = {1/oo}")

"""Символ бесконечности в основном используется функциями limit() и integrate() при задании пределов интегрирования,
о чем мы поговорим в одной из следующих статей."""
